// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: channel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Meshtastic protobufs
///
/// For more information on protobufs (and tools to use them with the language of your choice) see
/// https://developers.google.com/protocol-buffers/docs/proto3
///
/// We are not placing any of these defs inside a package, because if you do the
/// resulting nanopb version is super verbose package mesh.
///
/// Protobuf build instructions:
///
/// To build java classes for reading writing:
/// protoc -I=. --java_out /tmp mesh.proto
///
/// To generate Nanopb c code:
/// /home/kevinh/packages/nanopb-0.4.0-linux-x86/generator-bin/protoc --nanopb_out=/tmp -I=app/src/main/proto mesh.proto
///
/// Nanopb binaries available here: https://jpa.kapsi.fi/nanopb/download/ use nanopb 0.4.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Full settings (center freq, spread factor, pre-shared secret key etc...)
/// needed to configure a radio for speaking on a particular channel This
/// information can be encoded as a QRcode/url so that other users can configure
/// their radio to join the same channel.
/// A note about how channel names are shown to users: channelname-Xy
/// poundsymbol is a prefix used to indicate this is a channel name (idea from @professr).
/// Where X is a letter from A-Z (base 26) representing a hash of the PSK for this
/// channel - so that if the user changes anything about the channel (which does
/// force a new PSK) this letter will also change. Thus preventing user confusion if
/// two friends try to type in a channel name of "BobsChan" and then can't talk
/// because their PSKs will be different.
/// The PSK is hashed into this letter by "0x41 + [xor all bytes of the psk ] modulo 26"
/// This also allows the option of someday if people have the PSK off (zero), the
/// users COULD type in a channel name and be able to talk.
/// Y is a lower case letter from a-z that represents the channel 'speed' settings
/// (for some future definition of speed)
///
/// FIXME: Add description of multi-channel support and how primary vs secondary channels are used.
/// FIXME: explain how apps use channels for security.
/// explain how remote settings and remote gpio are managed as an example
struct ChannelSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If zero then, use default max legal continuous power (ie. something that won't
  /// burn out the radio hardware)
  /// In most cases you should use zero here.
  /// Units are in dBm.
  var txPower: Int32 = 0

  ///
  /// Note: This is the 'old' mechanism for specifying channel parameters.
  /// Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
  /// As a heuristic: If bandwidth is specified, do not use modem_config.
  /// Because protobufs take ZERO space when the value is zero this works out nicely.
  /// This value is replaced by bandwidth/spread_factor/coding_rate.
  /// If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
  var modemConfig: ChannelSettings.ModemConfig = .bw125Cr45Sf128

  ///
  /// Bandwidth in MHz
  /// Certain bandwidth numbers are 'special' and will be converted to the
  /// appropriate floating point value: 31 -> 31.25MHz
  var bandwidth: UInt32 = 0

  ///
  /// A number from 7 to 12.
  /// Indicates number of chirps per symbol as 1<<spread_factor.
  var spreadFactor: UInt32 = 0

  ///
  /// The denominator of the coding rate.
  /// ie for 4/8, the value is 8. 5/8 the value is 5.
  var codingRate: UInt32 = 0

  ///
  /// NOTE: this field is _independent_ and unrelated to the concepts in channel.proto.
  /// this is controlling the actual hardware frequency the radio is transmitting on.
  /// In a perfect world we would have called it something else (band?) but I forgot to make this change during the big 1.2 renaming.
  /// Most users should never need to be exposed to this field/concept.
  /// A channel number between 1 and 13 (or whatever the max is in the current
  /// region). If ZERO then the rule is "use the old channel name hash based
  /// algorithm to derive the channel number")
  /// If using the hash algorithm the channel number will be: hash(channel_name) %
  /// NUM_CHANNELS (Where num channels depends on the regulatory region).
  /// NUM_CHANNELS_US is 13, for other values see MeshRadio.h in the device code.
  /// hash a string into an integer - djb2 by Dan Bernstein. -
  /// http://www.cse.yorku.ca/~oz/hash.html
  /// unsigned long hash(char *str) {
  ///   unsigned long hash = 5381; int c;
  ///   while ((c = *str++) != 0)
  ///     hash = ((hash << 5) + hash) + (unsigned char) c;
  ///   return hash;
  /// }
  var channelNum: UInt32 = 0

  ///
  /// A simple pre-shared key for now for crypto.
  /// Must be either 0 bytes (no crypto), 16 bytes (AES128), or 32 bytes (AES256).
  /// A special shorthand is used for 1 byte long psks.
  /// These psks should be treated as only minimally secure,
  /// because they are listed in this source code.
  /// Those bytes are mapped using the following scheme:
  /// `0` = No crypto
  /// `1` = The special "default" channel key: {0xd4, 0xf1, 0xbb, 0x3a, 0x20, 0x29, 0x07, 0x59, 0xf0, 0xbc, 0xff, 0xab, 0xcf, 0x4e, 0x69, 0xbf}
  /// `2` through 10 = The default channel key, except with 1 through 9 added to the last byte.
  /// Shown to user as simple1 through 10
  var psk: Data = Data()

  ///
  /// A SHORT name that will be packed into the URL.
  /// Less than 12 bytes.
  /// Something for end users to call the channel
  /// If this is the empty string it is assumed that this channel
  /// is the special (minimally secure) "Default"channel.
  /// In user interfaces it should be rendered as a local language translation of "X".
  /// For channel_num hashing empty string will be treated as "X".
  /// Where "X" is selected based on the English words listed above for ModemConfig
  var name: String = String()

  ///
  /// Used to construct a globally unique channel ID.
  /// The full globally unique ID will be: "name.id" where ID is shown as base36.
  /// Assuming that the number of meshtastic users is below 20K (true for a long time)
  /// the chance of this 64 bit random number colliding with anyone else is super low.
  /// And the penalty for collision is low as well, it just means that anyone trying to decrypt channel messages might need to
  /// try multiple candidate channels.
  /// Any time a non wire compatible change is made to a channel, this field should be regenerated.
  /// There are a small number of 'special' globally known (and fairly) insecure standard channels.
  /// Those channels do not have a numeric id included in the settings, but instead it is pulled from
  /// a table of well known IDs.
  /// (see Well Known Channels FIXME)
  var id: UInt32 = 0

  ///
  /// If true, messages on the mesh will be sent to the *public* internet by any gateway ndoe
  var uplinkEnabled: Bool = false

  ///
  /// If true, messages seen on the internet will be forwarded to the local mesh.
  var downlinkEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Standard predefined channel settings 
  /// Note: these mappings must match ModemConfigChoice in the device code.
  enum ModemConfig: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// < Bw = 125 kHz, Cr = 4/5, Sf(7) = 128chips/symbol, CRC
    /// < on. Default medium range (5.469 kbps)
    case bw125Cr45Sf128 // = 0

    ///
    /// < Bw = 500 kHz, Cr = 4/5, Sf(7) = 128chips/symbol, CRC
    /// < on. Fast+short range (21.875 kbps)
    case bw500Cr45Sf128 // = 1

    ///
    /// < Bw = 31.25 kHz, Cr = 4/8, Sf(9) = 512chips/symbol,
    /// < CRC on. Slow+long range (275 bps)
    case bw3125Cr48Sf512 // = 2

    ///
    /// < Bw = 125 kHz, Cr = 4/8, Sf(12) = 4096chips/symbol, CRC
    /// < on. Slow+long range (183 bps)
    case bw125Cr48Sf4096 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .bw125Cr45Sf128
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bw125Cr45Sf128
      case 1: self = .bw500Cr45Sf128
      case 2: self = .bw3125Cr48Sf512
      case 3: self = .bw125Cr48Sf4096
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .bw125Cr45Sf128: return 0
      case .bw500Cr45Sf128: return 1
      case .bw3125Cr48Sf512: return 2
      case .bw125Cr48Sf4096: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ChannelSettings.ModemConfig: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ChannelSettings.ModemConfig] = [
    .bw125Cr45Sf128,
    .bw500Cr45Sf128,
    .bw3125Cr48Sf512,
    .bw125Cr48Sf4096,
  ]
}

#endif  // swift(>=4.2)

///
/// A pair of a channel number, mode and the (sharable) settings for that channel
struct Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The index of this channel in the channel table (from 0 to MAX_NUM_CHANNELS-1)
  /// (Someday - not currently implemented) An index of -1 could be used to mean "set by name", 
  /// in which case the target node will find and set the channel by settings.name. 
  var index: Int32 = 0

  ///
  /// The new settings, or NULL to disable that channel
  var settings: ChannelSettings {
    get {return _settings ?? ChannelSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  var role: Channel.Role = .disabled

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// How this channel is being used (or not).
  ///
  /// Note: this field is an enum to give us options for the future.
  /// In particular, someday we might make a 'SCANNING' option.
  /// SCANNING channels could have different frequencies and the radio would
  /// occasionally check that freq to see if anything is being transmitted.
  ///
  /// For devices that have multiple physical radios attached, we could keep multiple PRIMARY/SCANNING channels active at once to allow
  /// cross band routing as needed.
  /// If a device has only a single radio (the common case) only one channel can be PRIMARY at a time
  /// (but any number of SECONDARY channels can't be sent received on that common frequency)
  enum Role: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// This channel is not in use right now
    case disabled // = 0

    ///
    /// This channel is used to set the frequency for the radio - all other enabled channels must be SECONDARY
    case primary // = 1

    ///
    /// Secondary channels are only used for encryption/decryption/authentication purposes.
    /// Their radio settings (freq etc) are ignored, only psk is used. 
    case secondary // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .primary
      case 2: self = .secondary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .primary: return 1
      case .secondary: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _settings: ChannelSettings? = nil
}

#if swift(>=4.2)

extension Channel.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Channel.Role] = [
    .disabled,
    .primary,
    .secondary,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ChannelSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChannelSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_power"),
    3: .standard(proto: "modem_config"),
    6: .same(proto: "bandwidth"),
    7: .standard(proto: "spread_factor"),
    8: .standard(proto: "coding_rate"),
    9: .standard(proto: "channel_num"),
    4: .same(proto: "psk"),
    5: .same(proto: "name"),
    10: .same(proto: "id"),
    16: .standard(proto: "uplink_enabled"),
    17: .standard(proto: "downlink_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.txPower) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.modemConfig) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.psk) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.bandwidth) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.spreadFactor) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.codingRate) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.channelNum) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self.id) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.uplinkEnabled) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.downlinkEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.txPower != 0 {
      try visitor.visitSingularInt32Field(value: self.txPower, fieldNumber: 1)
    }
    if self.modemConfig != .bw125Cr45Sf128 {
      try visitor.visitSingularEnumField(value: self.modemConfig, fieldNumber: 3)
    }
    if !self.psk.isEmpty {
      try visitor.visitSingularBytesField(value: self.psk, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.bandwidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandwidth, fieldNumber: 6)
    }
    if self.spreadFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.spreadFactor, fieldNumber: 7)
    }
    if self.codingRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.codingRate, fieldNumber: 8)
    }
    if self.channelNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelNum, fieldNumber: 9)
    }
    if self.id != 0 {
      try visitor.visitSingularFixed32Field(value: self.id, fieldNumber: 10)
    }
    if self.uplinkEnabled != false {
      try visitor.visitSingularBoolField(value: self.uplinkEnabled, fieldNumber: 16)
    }
    if self.downlinkEnabled != false {
      try visitor.visitSingularBoolField(value: self.downlinkEnabled, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChannelSettings, rhs: ChannelSettings) -> Bool {
    if lhs.txPower != rhs.txPower {return false}
    if lhs.modemConfig != rhs.modemConfig {return false}
    if lhs.bandwidth != rhs.bandwidth {return false}
    if lhs.spreadFactor != rhs.spreadFactor {return false}
    if lhs.codingRate != rhs.codingRate {return false}
    if lhs.channelNum != rhs.channelNum {return false}
    if lhs.psk != rhs.psk {return false}
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.uplinkEnabled != rhs.uplinkEnabled {return false}
    if lhs.downlinkEnabled != rhs.downlinkEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChannelSettings.ModemConfig: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Bw125Cr45Sf128"),
    1: .same(proto: "Bw500Cr45Sf128"),
    2: .same(proto: "Bw31_25Cr48Sf512"),
    3: .same(proto: "Bw125Cr48Sf4096"),
  ]
}

extension Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "settings"),
    3: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.role != .disabled {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Channel, rhs: Channel) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Channel.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "PRIMARY"),
    2: .same(proto: "SECONDARY"),
  ]
}
